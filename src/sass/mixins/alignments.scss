// Minuet
// (c) VARIANTE (http://variante.io)
//
// This software is released under the MIT License:
// http://www.opensource.org/licenses/mit-license.php

/// Sets the margin of an element. Similar to the original 'margin' CSS rule,
/// except for the addition of 2 values: null and ''. If null is specified for
/// a specific side of the margin, that side will not be set. If '' is specified
/// for a specific side of the margin, it will take the value of the previous
/// side.
///
/// @param {number|List} $top    [null]  - Value for the top margin or a list of
///                                        values for each side of the margin
///                                        ordered by top, right, bottom and
///                                        left. Other than the first value, all
///                                        values are optional. If values are
///                                        left out, the behavior will be
///                                        similar to the original 'margin' CSS
///                                        rule (i.e. bottom matches top, right
///                                        matches left, etc).
/// @param {number}      $right  [unset] - Value for the right margin, if unset
///                                        this will be automatically inferred.
/// @param {number}      $bottom [unset] - Value for the bottom margin, if unset
///                                        this will be automatically inferred.
/// @param {number}      $left   [unset] - Value for the left margin, if unset
///                                        this will be automatically inferred.
///
/// @example
///   @include margin(0px);
///
///   // margin-top: 0px;
///   // margin-right: 0px;
///   // margin-bottom: 0px;
///   // margin-left: 0px;
///
/// @example
///   @include margin(0px 5px);
///
///   // margin-top: 0px;
///   // margin-right: 5px;
///   // margin-bottom: 0px;
///   // margin-left: 5px;
///
/// @example
///   @include margin(0px 5px '' null);
///
///   // margin-top: 0px;
///   // margin-right: 5px;
///   // margin-bottom: 5px;
///
/// @group alignments
@mixin margin($top:null, $right:unset, $bottom:unset, $left:unset) {
  $_top: if(length($top) > 1, nth($top, 1), $top);
  $_right: if(length($top) > 1, nth($top, 2), $_top);
  $_right: if($right == unset, $_right, $right);
  $_bottom: if(length($top) > 2, nth($top, 3), $_top);
  $_bottom: if($bottom == unset, $_bottom, $bottom);
  $_left: if(length($top) > 3, nth($top, 4), $_right);
  $_left: if($left == unset, $_left, $left);

  @if ($_right == '') { $_right: $_top; }
  @if ($_bottom == '') { $_bottom: $_right; }
  @if ($_left == '') { $_left: $_bottom; }

  @if ($_top != null) and ($_top != '-') { margin-top: $_top; }
  @if ($_right != null) and ($_right != '-') { margin-right: $_right; }
  @if ($_bottom != null) and ($_bottom != '-') { margin-bottom: $_bottom; }
  @if ($_left != null) and ($_left != '-') { margin-left: $_left; }
}

/// Sets the horizontal margins (i.e. left and right respectively). Values are
/// optional except for the first value. If null is specified, that side of
/// the margin will not be set. If '' is specified, the previous value will be
/// used instead (likewise if it is left out).
///
/// @param {number|List} $left  [null]  - Value for the left margin or a list of
///                                       up to 2 values for left and right
///                                       margins respectively.
/// @param {number}      $right [unset] - Value for the right margin. If unset,
///                                       this value will be automatically
///                                       inferred.
///
/// @group alignments
@mixin margin-h($left:null, $right:unset) {
  $_left: if(length($left) > 1, nth($left, 1), $left);
  $_right: if(length($left) > 1, nth($left, 2), $_left);
  $_right: if($right == unset, $_right, $right);

  @if ($_right == '') { $_right: $_left; }

  @if ($_left != null) and ($_left != '-') { margin-left: $_left; }
  @if ($_right != null) and ($_right != '-') { margin-right: $_right; }
}

/// Sets the vertical margins (i.e. top and bottom respectively). Values are
/// optional except for the first value. If null is specified, that side of
/// the margin will not be set. If '' is specified, the previous value will be
/// used instead (likewise if it is left out).
///
/// @param {number|List} $top    [null]  - Value for the top margin or a list of
///                                        up to 2 values for top and bottom
///                                        margins respectively.
/// @param {number}      $bottom [unset] - Value for the bottom margin. If unset,
///                                        this value will be automatically
///                                        inferred.
///
/// @group alignments
@mixin margin-v($top:null, $bottom:unset) {
  $_top: if(length($top) > 1, nth($top, 1), $top);
  $_bottom: if(length($top) > 1, nth($top, 2), $_top);
  $_bottom: if($bottom == unset, $_bottom, $bottom);

  @if ($_bottom == '') { $_right: $_top; }

  @if ($_top != null) and ($_top != '-') { margin-top: $_top; }
  @if ($_bottom != null) and ($_bottom != '-') { margin-bottom: $_bottom; }
}

/// Sets the padding of an element. Similar to the original 'padding' CSS rule,
/// except for the addition of 2 values: null and ''. If null is specified for
/// a specific side of the padding, that side will not be set. If '' is
/// specified for a specific side of the padding, it will take the value of the
/// previous side.
///
/// @param {number|List} $top    [null]  - Value for the top padding or a list of
///                                        values for each side of the padding
///                                        ordered by top, right, bottom and
///                                        left. Other than the first value, all
///                                        values are optional. If values are
///                                        left out, the behavior will be
///                                        similar to the original 'padding' CSS
///                                        rule (i.e. bottom matches top, right
///                                        matches left, etc).
/// @param {number}      $right  [unset] - Value for the right padding, if unset
///                                        this will be automatically inferred.
/// @param {number}      $bottom [unset] - Value for the bottom padding, if unset
///                                        this will be automatically inferred.
/// @param {number}      $left   [unset] - Value for the left padding, if unset
///                                        this will be automatically inferred.
///
/// @example
///   @include padding(0px);
///
///   // padding-top: 0px;
///   // padding-right: 0px;
///   // padding-bottom: 0px;
///   // padding-left: 0px;
///
/// @example
///   @include padding(0px 5px);
///
///   // padding-top: 0px;
///   // padding-right: 5px;
///   // padding-bottom: 0px;
///   // padding-left: 5px;
///
/// @example
///   @include padding(0px 5px '' null);
///
///   // padding-top: 0px;
///   // padding-right: 5px;
///   // padding-bottom: 5px;
///
/// @group alignments
@mixin padding($top:null, $right:unset, $bottom:unset, $left:unset) {
  $_top: if(length($top) > 1, nth($top, 1), $top);
  $_right: if(length($top) > 1, nth($top, 2), $_top);
  $_right: if($right == unset, $_right, $right);
  $_bottom: if(length($top) > 2, nth($top, 3), $_top);
  $_bottom: if($bottom == unset, $_bottom, $bottom);
  $_left: if(length($top) > 3, nth($top, 4), $_right);
  $_left: if($left == unset, $_left, $left);

  @if ($_right == '') { $_right: $_top; }
  @if ($_bottom == '') { $_bottom: $_right; }
  @if ($_left == '') { $_left: $_bottom; }

  @if ($_top != null) and ($_top != '-') { padding-top: $_top; }
  @if ($_right != null) and ($_right != '-') { padding-right: $_right; }
  @if ($_bottom != null) and ($_bottom != '-') { padding-bottom: $_bottom; }
  @if ($_left != null) and ($_left != '-') { padding-left: $_left; }
}

/// Sets the horizontal paddings (i.e. left and right respectively). Values are
/// optional except for the first value. If null is specified, that side of
/// the padding will not be set. If '' is specified, the previous value will be
/// used instead (likewise if it is left out).
///
/// @param {number|List} $left  [null]  - Value for the left padding or a list
///                                       of up to 2 values for left and right
///                                       margins respectively.
/// @param {number}      $right [unset] - Value for the right padding. If unset,
///                                       this value will be automatically
///                                       inferred.
///
/// @group alignments
@mixin padding-h($left:null, $right:unset) {
  $_left: if(length($left) > 1, nth($left, 1), $left);
  $_right: if(length($left) > 1, nth($left, 2), $_left);
  $_right: if($right == unset, $_right, $right);

  @if ($_right == '') { $_right: $_left; }

  @if ($_left != null) and ($_left != '-') { padding-left: $_left; }
  @if ($_right != null) and ($_right != '-') { padding-right: $_right; }
}

/// Sets the vertical paddings (i.e. top and bottom respectively). Values are
/// optional except for the first value. If null is specified, that side of
/// the padding will not be set. If '' is specified, the previous value will be
/// used instead (likewise if it is left out).
///
/// @param {number|List} $top    [null]  - Value for the top padding or a list
///                                        of up to 2 values for top and bottom
///                                        margins respectively.
/// @param {number}      $bottom [unset] - Value for the bottom padding. If unset,
///                                        this value will be automatically
///                                        inferred.
///
/// @group alignments
@mixin padding-v($top:null, $bottom:unset) {
  $_top: if(length($top) > 1, nth($top, 1), $top);
  $_bottom: if(length($top) > 1, nth($top, 2), $_top);
  $_bottom: if($bottom == unset, $_bottom, $bottom);

  @if ($_bottom == '') { $_right: $_top; }

  @if ($_top != null) and ($_top != '-') { padding-top: $_top; }
  @if ($_bottom != null) and ($_bottom != '-') { padding-bottom: $_bottom; }
}

/// Sets the edge of an element (i.e. top, right, bottom and left). This mixin
/// makes setting edges similar to margins and paddings where you can apply
/// a list of up to 4 values to set all edges. If null is specified for a
/// specific edge, that edge will not be set. If '' is specified for a specific
/// edge, it will take the value of the previous edge.
///
/// @param {number|List} $top    [null]  - Value for the top edge or a list of
///                                        values for each side of the edge
///                                        ordered by top, right, bottom and
///                                        left. Other than the first value, all
///                                        values are optional. If values are
///                                        left out, the behavior will be
///                                        similar to the original 'margin' CSS
///                                        rule (i.e. bottom matches top, right
///                                        matches left, etc).
/// @param {number}      $right  [unset] - Value for the right edge, if unset
///                                        this will be automatically inferred.
/// @param {number}      $bottom [unset] - Value for the bottom edge, if unset
///                                        this will be automatically inferred.
/// @param {number}      $left   [unset] - Value for the left edge, if unset
///                                        this will be automatically inferred.
///
/// @example
///   @include edge(0px);
///
///   // top: 0px;
///   // right: 0px;
///   // bottom: 0px;
///   // left: 0px;
///
/// @example
///   @include edge(0px 5px);
///
///   // top: 0px;
///   // right: 5px;
///   // bottom: 0px;
///   // left: 5px;
///
/// @example
///   @include edge(0px 5px '' null);
///
///   // top: 0px;
///   // right: 5px;
///   // bottom: 5px;
///
/// @group alignments
@mixin edge($top:null, $right:unset, $bottom:unset, $left:unset) {
  $_top: if(length($top) > 1, nth($top, 1), $top);
  $_right: if(length($top) > 1, nth($top, 2), $_top);
  $_right: if($right == unset, $_right, $right);
  $_bottom: if(length($top) > 2, nth($top, 3), $_top);
  $_bottom: if($bottom == unset, $_bottom, $bottom);
  $_left: if(length($top) > 3, nth($top, 4), $_right);
  $_left: if($left == unset, $_left, $left);

  @if ($_right == '') { $_right: $_top; }
  @if ($_bottom == '') { $_bottom: $_right; }
  @if ($_left == '') { $_left: $_bottom; }

  @if ($_top != null) and ($_top != '-') { top: $_top; }
  @if ($_right != null) and ($_right != '-') { right: $_right; }
  @if ($_bottom != null) and ($_bottom != '-') { bottom: $_bottom; }
  @if ($_left != null) and ($_left != '-') { left: $_left; }
}

/// Sets the horizontal edges (i.e. left and right respectively). Values are
/// optional except for the first value. If null is specified, that side of
/// the edge will not be set. If '' is specified, the previous value will be
/// used instead (likewise if it is left out).
///
/// @param {number|List} $left  [null]  - Value for the left edge or a list of
///                                       up to 2 values for left and right
///                                       margins respectively.
/// @param {number}      $right [unset] - Value for the right edge. If unset,
///                                       this value will be automatically
///                                       inferred.
///
/// @group alignments
@mixin edge-h($left:null, $right:unset) {
  $_left: if(length($left) > 1, nth($left, 1), $left);
  $_right: if(length($left) > 1, nth($left, 2), $_left);
  $_right: if($right == unset, $_right, $right);

  @if ($_right == '') { $_right: $_left; }

  @if ($_left != null) and ($_left != '-') { left: $_left; }
  @if ($_right != null) and ($_right != '-') { right: $_right; }
}

/// Sets the vertical edges (i.e. top and bottom respectively). Values are
/// optional except for the first value. If null is specified, that side of
/// the edge will not be set. If '' is specified, the previous value will be
/// used instead (likewise if it is left out).
///
/// @param {number|List} $top    [null]  - Value for the top edge or a list of
///                                        up to 2 values for top and bottom
///                                        margins respectively.
/// @param {number}      $bottom [unset] - Value for the bottom edge. If unset,
///                                        this value will be automatically
///                                        inferred.
///
/// @group alignments
@mixin edge-v($top:null, $bottom:unset) {
  $_top: if(length($top) > 1, nth($top, 1), $top);
  $_bottom: if(length($top) > 1, nth($top, 2), $_top);
  $_bottom: if($bottom == unset, $_bottom, $bottom);

  @if ($_bottom == '') { $_right: $_top; }

  @if ($_top != null) and ($_top != '-') { top: $_top; }
  @if ($_bottom != null) and ($_bottom != '-') { bottom: $_bottom; }
}

/// Clearfix hack for floated elements.
///
/// @group alignments
@mixin clearfix() {
  *zoom: 1;

  &:before {
    content: '';
    display: table;
  }

  &:after {
    content: '';
    display: table;
    clear: both;
  }
}

/// Transforms an element into a container of the specified type. Special cases
/// include 'fluid' blocks and 'flex' blocks. 'fluid' containers can freely
/// align child inline-blocks with no fixed width/height requirements. 'flex'
/// containers can specify the flex direction. Wrap the $type with '()' or
/// prefix it with 'inline-' to use the inline counterpart of the block type.
///
/// @param {string}      $type          - Type of container. This complies to
///                                       the standard 'display' CSS rule, with
///                                       the exception of the following special
///                                       cases:
///                                       1.  'fluid'
///                                       2.  '(fluid)' or 'inline-fluid'
///                                       3.  'flex'
///                                       4.  '(flex)' or 'inline-flex'
///                                       5.  'flex>' (row)
///                                       6.  '(flex>)' or 'inline-flex>'
///                                       7.  'flex<' (row-reverse)
///                                       8.  '(flex<)' or 'inline-flex<'
///                                       9.  'flex^' (column-reverse)
///                                       10. '(flex^)' or 'inline-flex^'
///                                       11.  'flexv' (column)
///                                       12. '(flexv)' or 'inline-flexv'
///                                       13.  'box' (same as 'boxv')
///                                       14.  '(box)' or 'inline-box'
///                                       15.  'box>' (row)
///                                       16.  '(box>)' or 'inline-box>'
///                                       17.  'box<' (row-reverse)
///                                       18.  '(box<)' or 'inline-box<'
///                                       19.  'box^' (column-reverse)
///                                       20. '(box^)' or 'inline-box^'
///                                       21.  'boxv' (column)
///                                       22. '(boxv)' or 'inline-boxv'
///
/// @param {string|List} $align1 [null] - Internal alignment, can be a string or
///                                       a list of 2 strings.
/// @param {string}      $align2 [null] - Internal alignment adjacent to $align1.
///
/// @group alignments
@mixin display($type, $align1:null, $align2:null) {
  $_default: if($align1 == null, if(str-index($type, 'box') != null, center, (top left)), $align1);
  $_align1: if(length($_default) > 1, nth($_default, 1), $_default);
  $_align2: if(length($_default) > 1, nth($_default, 2), 'center');
  $_align2: if($align2 == null, $_align2, nth($align2, 1));
  $_h: if($_align1 == 'left' or $_align1 == 'right', $_align1, 'center');
  $_h: if($_align2 == 'left' or $_align2 == 'right', $_align2, $_h);
  $_v: if($_align1 == 'top' or $_align1 == 'bottom', $_align1, 'center');
  $_v: if($_align2 == 'top' or $_align2 == 'bottom', $_align2, $_v);

  @if ($type == '()') {
    display: inline;
  } @else if ($type == '(block)') {
    display: inline-block;
  } @else if (str-index($type, 'fluid') != null) {
    @if      ($_h == 'left')   { text-align: left;   }
    @else if ($_h == 'center') { text-align: center; }
    @else if ($_h == 'right')  { text-align: right;  }

    @if      ($_v == 'top')    { & > * { vertical-align: top;    } }
    @else if ($_v == 'center') { & > * { vertical-align: middle; } }
    @else if ($_v == 'bottom') { & > * { vertical-align: bottom; } }

    & > * { display: inline-block; }

    @if (str-index($type, 'inline') == 1) or (str-index($type, '(') == 1) {
      display: inline-block;
    } @else {
      display: block;
    }

    &:before {
      content: '';
      display: inline-block;
      height: 100%;
      vertical-align: middle;
    }
  } @else if (str-index($type, 'box') != null) {
    @if (str-index($type, '<') != null) {
      flex-direction: row-reverse;

      @if      ($_h == 'left')   { justify-content: flex-end;   }
      @else if ($_h == 'center') { justify-content: center;     }
      @else if ($_h == 'right')  { justify-content: flex-start; }

      @if      ($_v == 'top')    { align-items: flex-start; align-content: flex-start; }
      @else if ($_v == 'center') { align-items: center;     align-content: center;     }
      @else if ($_v == 'bottom') { align-items: flex-end;   align-content: flex-end;   }
    } @else if (str-index($type, '^') != null) {
      flex-direction: column-reverse;

      @if      ($_v == 'top')    { justify-content: flex-end;   }
      @else if ($_v == 'center') { justify-content: center;     }
      @else if ($_v == 'bottom') { justify-content: flex-start; }

      @if      ($_h == 'left')   { align-items: flex-start; align-content: flex-start; }
      @else if ($_h == 'center') { align-items: center;     align-content: center;     }
      @else if ($_h == 'right')  { align-items: flex-end;   align-content: flex-end;   }
    } @else {
      flex-direction: row;

      @if      ($_h == 'left')   { justify-content: flex-start; }
      @else if ($_h == 'center') { justify-content: center;     }
      @else if ($_h == 'right')  { justify-content: flex-end;   }

      @if      ($_v == 'top')    { align-items: flex-start; align-content: flex-start; }
      @else if ($_v == 'center') { align-items: center;     align-content: center;     }
      @else if ($_v == 'bottom') { align-items: flex-end;   align-content: flex-end;   }
    } @else {
      flex-direction: column;

      @if      ($_v == 'top')    { justify-content: flex-start; }
      @else if ($_v == 'center') { justify-content: center;     }
      @else if ($_v == 'bottom') { justify-content: flex-end;   }

      @if      ($_h == 'left')   { align-items: flex-start; align-content: flex-start; }
      @else if ($_h == 'center') { align-items: center;     align-content: center;     }
      @else if ($_h == 'right')  { align-items: flex-end;   align-content: flex-end;   }
    }

    @if (str-index($type, 'inline') == 1) or (str-index($type, '(') == 1) {
      display: inline-flex;
    } @else {
      display: flex;
    }

    flex-wrap: nowrap;
    line-height: normal;
    white-space: normal;

    > * {
      flex-shrink: 1;
      flex-basis: auto;
    }
  } @else if (str-index($type, 'flex') != null) {
    @if (str-index($type, '<') != null) {
      flex-direction: row-reverse;

      @if      ($_h == 'left')   { justify-content: flex-end;   }
      @else if ($_h == 'center') { justify-content: center;     }
      @else if ($_h == 'right')  { justify-content: flex-start; }

      @if      ($_v == 'top')    { align-content: flex-start; }
      @else if ($_v == 'center') { align-content: center;     }
      @else if ($_v == 'bottom') { align-content: flex-end;   }
    } @else if (str-index($type, 'v') != null) {
      flex-direction: column;

      @if      ($_v == 'top')    { justify-content: flex-start; }
      @else if ($_v == 'center') { justify-content: center;     }
      @else if ($_v == 'bottom') { justify-content: flex-end;   }

      @if      ($_h == 'left')   { align-content: flex-start; }
      @else if ($_h == 'center') { align-content: center;     }
      @else if ($_h == 'right')  { align-content: flex-end;   }
    } @else if (str-index($type, '^') != null) {
      flex-direction: column-reverse;

      @if      ($_v == 'top')    { justify-content: flex-end;   }
      @else if ($_v == 'center') { justify-content: center;     }
      @else if ($_v == 'bottom') { justify-content: flex-start; }

      @if      ($_h == 'left')   { align-content: flex-start; }
      @else if ($_h == 'center') { align-content: center;     }
      @else if ($_h == 'right')  { align-content: flex-end;   }
    } @else {
      flex-direction: row;

      @if      ($_h == 'left')   { justify-content: flex-start; }
      @else if ($_h == 'center') { justify-content: center;     }
      @else if ($_h == 'right')  { justify-content: flex-end;   }

      @if      ($_v == 'top')    { align-content: flex-start; }
      @else if ($_v == 'center') { align-content: center;     }
      @else if ($_v == 'bottom') { align-content: flex-end;   }
    }

    @if (str-index($type, 'inline') == 1) or (str-index($type, '(') == 1) {
      display: inline-flex;
    } @else {
      display: flex;
    }

    align-items: stretch;
    flex-wrap: nowrap;
    line-height: normal;
    white-space: normal;

    > * {
      flex-shrink: 1;
      flex-basis: auto;
    }
  } @else {
    display: unquote($type);
  }
}

/// Transforms containing selector into a container that can freely align child
/// inline-blocks with no fixed width/height requirements. Beware of whitespace
/// between inline elements.
///
/// @param {List}   $alignH ['center'] - Horizontal alignment of child elements
///                                      (i.e. left, center, right). Option to
///                                      specify left/right paddings
///                                      respectively.
/// @param {List}   $alignV ['center'] - Vertical alignment of child elements
///                                      (i.e. top, center, bototm). Option to
///                                      specify top/bottom paddings
///                                      respectively.
/// @param {string} $inline [false]    - Specifies if this block is an inline
///                                      block.
///
/// @group alignments
@mixin fluid-block($alignH:'center', $alignV:'center', $inline:false) {
  @if $alignH != null and length($alignH) > 0 {
    @if length($alignH) > 1 { padding-left: nth($alignH, 2);  }
    @if length($alignH) > 2 { padding-right: nth($alignH, 3); }
  }

  @if $alignV != null and length($alignV) > 0 {
    @if length($alignV) > 1 { padding-top: nth($alignV, 2);    }
    @if length($alignV) > 2 { padding-bottom: nth($alignV, 3); }
  }

  $h: nth($alignH, 1);
  $v: nth($alignV, 1);

  @if      $h == 'left'                     { text-align: left;   }
  @else if $h == 'center' or $h == 'middle' { text-align: center; }
  @else if $h == 'right'                    { text-align: right;  }

  @if      $v == 'top'                      { & > * { vertical-align: top;    } }
  @else if $v == 'center' or $v == 'middle' { & > * { vertical-align: middle; } }
  @else if $v == 'bottom'                   { & > * { vertical-align: bottom; } }

  @if   $inline == true { display: inline-block; }
  @else                 { display: block;        }

  & > * {
    display: inline-block;
  }

  &:before {
    height: 100%;
    vertical-align: middle;
    content: '';
    display: inline-block;
  }
}

/// Transforms containing selector into a flexbox which auto aligns child
/// elements according to the specified params.
///
/// @param {List}    $alignH ['center'] - Horizontal alignment of child elements
///                                       (i.e. left, center, right). Option to
///                                       specify left/right paddings
///                                       respectively.
/// @param {List}    $alignV ['center'] - Vertical alignment of child elements
///                                       (i.e. top, middle, bottom). Option to
///                                       specify top/bottom paddings
///                                       respectively.
/// @param {boolean} $direction [row]   - Determines the main axis (i.e. row,
///                                       row-reverse, column, column-reverse).
/// @param {boolean} $wrap [false]      - Determines if wrapping is enabled.
/// @param {string}  $inline [false]    - Specifies if this flexbox is inline.
/// @param {string}  $uniform [false]   - Specifies if this flexbox has uniform
///                                       sized items.
///
/// @group alignments
@mixin flex-block($alignH:'center', $alignV:'center', $direction:row, $wrap:false, $inline:false, $uniform:false) {
  line-height: normal;
  white-space: normal;

  & > * {
    flex-shrink: if($wrap == true, 1, 0);
  }

  @if $uniform == true {
    & > * {
      flex-grow: 1;
      flex-basis: 0;
    }
  }

  @if   $wrap == true { flex-wrap: wrap; flex-shrink: 1; }
  @else               { flex-wrap: nowrap; }

  @if $alignH != null and length($alignH) > 0 {
    @if length($alignH) > 1 { padding-left: nth($alignH, 2);  }
    @if length($alignH) > 2 { padding-right: nth($alignH, 3); }
  }

  @if $alignV != null and length($alignV) > 0 {
    @if length($alignV) > 1 { padding-top: nth($alignV, 2);    }
    @if length($alignV) > 2 { padding-bottom: nth($alignV, 3); }
  }

  $h: nth($alignH, 1);
  $v: nth($alignV, 1);

  @if $direction == 'row' {
    flex-direction: row;

    @if      $h == 'left'                     { justify-content: flex-start; }
    @else if $h == 'center' or $h == 'middle' { justify-content: center;     }
    @else if $h == 'right'                    { justify-content: flex-end;   }

    @if      $v == 'top'                      { align-items: flex-start; align-content: flex-start; }
    @else if $v == 'center' or $v == 'middle' { align-items: center;     align-content: center;     }
    @else if $v == 'bottom'                   { align-items: flex-end;   align-content: flex-end;   }
  }
  @else if $direction == 'row-reverse' {
    flex-direction: row-reverse;

    @if      $h == 'left'                     { justify-content: flex-end;   }
    @else if $h == 'center' or $h == 'middle' { justify-content: center;     }
    @else if $h == 'right'                    { justify-content: flex-start; }

    @if      $v == 'top'                      { align-items: flex-start; align-content: flex-start; }
    @else if $v == 'center' or $v == 'middle' { align-items: center;     align-content: center;     }
    @else if $v == 'bottom'                   { align-items: flex-end;   align-content: flex-end;   }
  }
  @else if $direction == 'column' {
    flex-direction: column;

    @if      $v == 'top'                       { justify-content: flex-start; }
    @else if $v == 'center' or $v == 'middle'  { justify-content: center;     }
    @else if $v == 'bottom'                    { justify-content: flex-end;   }

    @if      $h == 'left'                     { align-items: flex-start; align-content: flex-start; }
    @else if $h == 'center' or $h == 'middle' { align-items: center;     align-content: center;     }
    @else if $h == 'right'                    { align-items: flex-end;   align-content: flex-end;   }
  }
  @else if $direction == 'column-reverse' {
    flex-direction: column-reverse;

    @if      $v == 'top'                       { justify-content: flex-end;   }
    @else if $v == 'center' or $v == 'middle'  { justify-content: center;     }
    @else if $v == 'bottom'                    { justify-content: flex-start; }

    @if      $h == 'left'                     { align-items: flex-start; align-content: flex-start; }
    @else if $h == 'center' or $h == 'middle' { align-items: center;     align-content: center;     }
    @else if $h == 'right'                    { align-items: flex-end;   align-content: flex-end;   }
  }

  @if   $inline == true { display: inline-flex; }
  @else                 { display: flex;        }
}

/// Transforms the containing selector into a grid driven by flexbox. This grid
/// supports the 4 directions available in flex-direction. It is not a good idea
/// to directly tweak the margin and padding rules of this grid. If you must
/// specify a margin, either put this grid in a parent container and tweak the
/// margins of that instead, or manually take the internal paddings of the grid
/// into account. The same goes for the individual items inside the grid. If the
/// margin/padding rules must be tweaked, it is a better idea to have a child
/// container and tweak the rules of that instead.
///
/// @param {List}    $size [auto]    - Specifies the size of this grid,
///                                        complies to the size mixin.
/// @param {string}  $direction [row]    - Specifies the direction of this grid,
///                                        complies to the rules supported by
///                                        flex-direction.
/// @param {number}  $base-length [auto] - The length of the fixed side of the
///                                        items. If the direction of the grid
///                                        is horizontal, this value would refer
///                                        to the row height. Similarly, if the
///                                        direction of the grid is vertical,
///                                        this value would refer to the column
///                                        width.
/// @param {number}  $base-count [0]     - The number of items in this grid's
///                                        direction. For example, if the
///                                        direction is horizontal, this value
///                                        would refer to the number of columns.
///                                        This value must be greater than or
///                                        equal to 0. If number is 0, there will
///                                        not be a fixed number of items per
///                                        direction - the items will simply
///                                        position freely as long as a given
///                                        direction has enough room. If this
///                                        value is greater than 0, each item
///                                        will have an automatically assigned
///                                        length to the side that is parallel to
///                                        the direction.
/// @param {List}    $padding [0px true] - Specifies the padding between each
///                                        grid item. The first value specifies
///                                        the actual length of the gap, whereas
///                                        the second value is a boolean that
///                                        specifies whether gaps should be
///                                        applied to outmost items (hence the
///                                        grid itself will have an inner padding
///                                        of the gap value).
/// @param {boolean} $autosize [false]   - Specifies whether grid items will
///                                        automatically fill the rest of the
///                                        grid if there are empty spaces.
///
/// @group alignments
@mixin flex-grid($size:auto, $direction:row, $base-length:auto, $base-count:0, $padding:0px true, $autosize:false) {
  @if ($base-count < 0) { @warn 'Value provided for base-count must be >= 0'; }

  $_bordered: if(length($padding) > 1, nth($padding, 2), true);
  $_padding: nth($padding, 1);
  $_basis: auto;
  $_orientation: if($direction == 'row' or $direction == 'row-reverse', 'horizontal', 'vertical');
  $_width: nth($size, 1);
  $_height: if(length($size) > 1, nth($size, 2), nth($size, 1));

  @include flex-block('left', 'top', $direction, true);
  @include size($size);
  width: if((type-of($_width) == number) and ($_bordered == false), calc(#{$_width} + #{$_padding}), $_width);
  height: if((type-of($_height) == number) and ($_bordered == false), calc(#{$_height} + #{$_padding}), $_height);
  margin: if($_bordered == true, 0, #{-$_padding} 0 0 #{-$_padding});
  padding: if($_bordered == true, #{$_padding / 2}, 0);

  & > * {
    margin: if($_bordered == true, #{$_padding / 2}, #{$_padding} 0 0 #{$_padding});
    flex-basis: auto;
    flex-grow: if($autosize == true, 1, 0);
    flex-shrink: 0;
    overflow: hidden;

    @if ($base-count > 0) {
      @if ($_bordered == true) {
        & &.base-1 { flex-basis: calc(#{100 / $base-count * min(1, $base-count)}% - #{$_padding}); }
        &.base-2   { flex-basis: calc(#{100 / $base-count * min(2, $base-count)}% - #{$_padding}); }
        &.base-3   { flex-basis: calc(#{100 / $base-count * min(3, $base-count)}% - #{$_padding}); }
        &.base-4   { flex-basis: calc(#{100 / $base-count * min(4, $base-count)}% - #{$_padding}); }
        &.base-5   { flex-basis: calc(#{100 / $base-count * min(5, $base-count)}% - #{$_padding}); }
        &.base-6   { flex-basis: calc(#{100 / $base-count * min(6, $base-count)}% - #{$_padding}); }
      }
      @else {
        &, &.base-1 { flex-basis: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(1, $base-count)} + #{$_padding * (min(1, $base-count) - 1)}); }
        &.base-2    { flex-basis: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(2, $base-count)} + #{$_padding * (min(2, $base-count) - 1)}); }
        &.base-3    { flex-basis: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(3, $base-count)} + #{$_padding * (min(3, $base-count) - 1)}); }
        &.base-4    { flex-basis: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(4, $base-count)} + #{$_padding * (min(4, $base-count) - 1)}); }
        &.base-5    { flex-basis: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(5, $base-count)} + #{$_padding * (min(5, $base-count) - 1)}); }
        &.base-6    { flex-basis: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(6, $base-count)} + #{$_padding * (min(6, $base-count) - 1)}); }
      }
    }

    @if ($_orientation == 'horizontal') {
      @if ($base-count > 0) {
        @if ($_bordered == true) {
          &, &.base-1 { width: calc(#{100 / $base-count * min(1, $base-count)}% - #{$_padding}); }
          &.base-2    { width: calc(#{100 / $base-count * min(2, $base-count)}% - #{$_padding}); }
          &.base-3    { width: calc(#{100 / $base-count * min(3, $base-count)}% - #{$_padding}); }
          &.base-4    { width: calc(#{100 / $base-count * min(4, $base-count)}% - #{$_padding}); }
          &.base-5    { width: calc(#{100 / $base-count * min(5, $base-count)}% - #{$_padding}); }
          &.base-6    { width: calc(#{100 / $base-count * min(6, $base-count)}% - #{$_padding}); }
        }
        @else {
          &, &.base-1 { width: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(1, $base-count)} + #{$_padding * (min(1, $base-count) - 1)}); }
          &.base-2    { width: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(2, $base-count)} + #{$_padding * (min(2, $base-count) - 1)}); }
          &.base-3    { width: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(3, $base-count)} + #{$_padding * (min(3, $base-count) - 1)}); }
          &.base-4    { width: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(4, $base-count)} + #{$_padding * (min(4, $base-count) - 1)}); }
          &.base-5    { width: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(5, $base-count)} + #{$_padding * (min(5, $base-count) - 1)}); }
          &.base-6    { width: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(6, $base-count)} + #{$_padding * (min(6, $base-count) - 1)}); }
        }
      }

      height: $base-length;
    }
    @else {
      width: $base-length;

      @if ($base-count > 0) {
        @if ($_bordered == true) {
          &, &.base-1 { height: calc(#{100 / $base-count * min(1, $base-count)}% - #{$_padding}); }
          &.base-2    { height: calc(#{100 / $base-count * min(2, $base-count)}% - #{$_padding}); }
          &.base-3    { height: calc(#{100 / $base-count * min(3, $base-count)}% - #{$_padding}); }
          &.base-4    { height: calc(#{100 / $base-count * min(4, $base-count)}% - #{$_padding}); }
          &.base-5    { height: calc(#{100 / $base-count * min(5, $base-count)}% - #{$_padding}); }
          &.base-6    { height: calc(#{100 / $base-count * min(6, $base-count)}% - #{$_padding}); }
        }
        @else {
          &, &.base-1 { height: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(1, $base-count)} + #{$_padding * (min(1, $base-count) - 1)}); }
          &.base-2    { height: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(2, $base-count)} + #{$_padding * (min(2, $base-count) - 1)}); }
          &.base-3    { height: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(3, $base-count)} + #{$_padding * (min(3, $base-count) - 1)}); }
          &.base-4    { height: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(4, $base-count)} + #{$_padding * (min(4, $base-count) - 1)}); }
          &.base-5    { height: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(5, $base-count)} + #{$_padding * (min(5, $base-count) - 1)}); }
          &.base-6    { height: calc((100% - #{$_padding * ($base-count)}) / #{$base-count} * #{min(6, $base-count)} + #{$_padding * (min(6, $base-count) - 1)}); }
        }
      }
    }
  }
}

/// Aligns an element horizontally and vertically.
///
/// @param {List}   $alignH ['left']     - List of up to 3 values that describes
///                                        the horizontal alignment. First value
///                                        represents the direction (i.e. left,
///                                        center, right) and the second and
///                                        third value are the left and right
///                                        edges respectively.
/// @param {List}   $alignV ['top']      - List of up to 3 values that describes
///                                        the vertical alignment. First value
///                                        represents the direction (i.e. top,
///                                        center, bottom) and the second and
///                                        third value are the top and bottom
///                                        edges respectively.
/// @param {string} $type ['absolute']   - Specifies the position type (i.e.
///                                        absolute or fixed).
///
/// @group alignments
@mixin align($alignH:'left', $alignV:'top', $type:'absolute') {
  @if ($type == 'absolute') or ($type == 'abs') {
    @include abs-align($alignH, $alignV);
  }
  @else if ($type == 'fixed') or ($type == 'fix') {
    @include fixed-align($alignH, $alignV);
  }
  @else if ($type == 'inline') {
    @include inline-align($alignH, $alignV);
  }
}

/// Aligns containing selector to specified x/y directions in absolute position.
///
/// @param {List} $alignH ['left'] - Horizontal alignment (left|center|right,
///                                  left|right offset, right offset).
/// @param {List} $alignV ['top']  - Vertical alignment (top|center|middle|bottom,
///                                  top|bottom offset, bottom offset).
///
/// @group alignments
@mixin abs-align($alignH:'left', $alignV:'top') {
  @include edge(auto);
  @include margin(0);
  position: absolute;

  @if $alignH != null and length($alignH) > 0 {
    $align: nth($alignH, 1);
    $left: if(length($alignH) > 1, nth($alignH, 2), null);
    $right: if(length($alignH) > 2, nth($alignH, 3), null);

    @if $align == 'left' {
      left: 0px;
    }
    @else if $align == 'center' or $align == 'middle' {
      @include margin-h(auto);
      left: 0px;
      right: 0px;
    }
    @else if $align == 'right' {
      right: 0px;
    }

    @include edge-h($left $right);
  }

  @if $alignV != null and length($alignV) > 0 {
    $align: nth($alignV, 1);
    $top: if(length($alignV) > 1, nth($alignV, 2), null);
    $bottom: if(length($alignV) > 2, nth($alignV, 3), null);

    @if $align == 'top' {
      top: 0px;
    }
    @else if $align == 'center' or $align == 'middle' {
      @include margin-v(auto);
      top: 0px;
      bottom: 0px;
    }
    @else if $align == 'bottom' {
      bottom: 0px;
    }

    @include edge-v($top $bottom);
  }
}

// Aligns containing selector to specified x/y directions in fixed position.
//
// @param {List} $alignH ['left'] - Horizontal alignment (left|center|right,
//                                  left|right offset, right offset).
// @param {List} $alignV ['top']  - Vertical alignment (top|center|middle|bottom,
//                                  top|bottom offset, bottom offset).
//
// @group alignments
@mixin fixed-align($alignH:'left', $alignV:'top') {
  @include abs-align($alignH, $alignV);
  position: fixed;
}

/// Aligns containing inline-block to specified x/y directions in relative
/// position.
///
/// @param {string} $alignH ['left'] - Horizontal alignment (i.e. left, center,
///                                    right).
/// @param {string} $alignV ['top']  - Vertical alignment (i.e. top, middle,
///                                    bottom).
///
/// @group alignments
@mixin inline-align($alignH:'left', $alignV:'top') {
  position: relative;

  // Horizontal alignment cannot be altered at the child level. Tweak the
  // parent's text-align rule instead.

  @if      $alignV == 'top'                           { vertical-align: top;    }
  @else if $alignV == 'center' or $alignV == 'middle' { vertical-align: middle; }
  @else if $alignV == 'bottom'                        { vertical-align: bottom; }
}

/// Transforms target selector into a container for parallax elements.
///
/// @param {number} $perspective [1] - Tweak this value to adjust perspective.
///
/// @see {mixin} parallax-element
///
/// @group alignments
@mixin parallax-block($perspective:1) {
  height: 100vh;
  overflow-x: hidden;
  overflow-y: scroll;
  perspective: #{$perspective + px};
  transform-style: preserve-3d;
}

/// Transforms target selector into a parallax element. The target selector must
/// be a child of a parallax-block.
///
/// @param {number} $z [0] - Position in the z-axis.
///
/// @see {mixin} parallax-block
///
/// @group alignments
@mixin parallax-element($z:0) {
  transform: translateZ(#{$z}px);
}

/// Sets the size of the target selector.
///
/// @param {number|List} $width          - Specifies the width and height of the
///                                        selector. If only 1 value is provided,
///                                        both width and height will use that
///                                        value. If 2 values are provided, they
///                                        will be used for width and height
///                                        respectively.
/// @param {number}      $height [unset] - Specifies the height (overrides
///                                        the previous parameter).
/// @param {boolean}     $oval [false]   - Specifies whether the selector is
///                                        oval shaped (hence rounded corners
///                                        corresponding to the shortest side).
///
/// @group alignments
@mixin size($width, $height:unset, $oval:false) {
  $_width: if(length($width) > 1, nth($width, 1), $width);
  $_height: if(length($width) > 1, nth($width, 2), $_width);
  $_height: if($height == unset or $height == true or $height == false, $_height, $height);
  $_oval: if($height == true or $height == false, $height, $oval);

  @if ($_height == '') { $_height: $_width; }

  @if ($_width != null) and ($_width != '-') and ($_width != 'x') and ($_width != 'n') {
    width: $_width;
  }

  @if ($_height != null) and ($_height != '-') and ($_height != 'x') and ($_height != 'n') {
    height: $_height;
  }

  @if ($_oval == true) {
    @include overflow(hidden);
    border-radius: (min($_width, $_height) / 2);
  }
}

/// Sets the max size of the target selector.
///
/// @param {number|List} $width          - Specifies the max width and height of
///                                        the selector. If only 1 value is
///                                        provided, both max-width and
///                                        max-height will use that value. If 2
///                                        values are provided, they will be
///                                        used for max-width and max-height
///                                        respectively.
/// @param {number}      $height [unset] - Specifies the max height (overrides
///                                        the previous parameter).
///
/// @group alignments
@mixin max-size($width, $height:unset) {
  $_width: if(length($width) > 1, nth($width, 1), $width);
  $_height: if(length($width) > 1, nth($width, 2), $_width);
  $_height: if($height == unset, $_height, $height);

  @if ($_height == '') { $_height: $_width; }

  @if ($_width != null) and ($_width != '-') and ($_width != 'x') and ($_width != 'n') {
    max-width: $_width;
  }

  @if ($_height != null) and ($_height != '-') and ($_height != 'x') and ($_height != 'n') {
    max-height: $_height;
  }
}

/// Sets the min size of the target selector.
///
/// @param {number|List} $width          - Specifies the min width and height of
///                                        the selector. If only 1 value is
///                                        provided, both min-width and
///                                        min-height will use that value. If 2
///                                        values are provided, they will be
///                                        used for min-width and min-height
///                                        respectively.
/// @param {number}      $height [unset] - Specifies the min height (overrides
///                                        the previous parameter).
///
/// @group alignments
@mixin min-size($width, $height:unset) {
  $_width: if(length($width) > 1, nth($width, 1), $width);
  $_height: if(length($width) > 1, nth($width, 2), $_width);
  $_height: if($height == unset, $_height, $height);

  @if ($_height == '') { $_height: $_width; }

  @if ($_width != null) and ($_width != '-') and ($_width != 'x') and ($_width != 'n') {
    min-width: $_width;
  }

  @if ($_height != null) and ($_height != '-') and ($_height != 'x') and ($_height != 'n') {
    min-height: $_height;
  }
}

/// Applies mask to target selector.
///
/// @group alignments
@mixin mask() {
  overflow: hidden;
  -webkit-mask-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC);
}

/// Hides the target selector.
///
/// @param {boolean} $forced [true] - Specifies whether !important is tagged.
///
/// @group alignments
@mixin hidden($forced:true) {
  @if ($forced == true) {
    display: none !important;
  }
  @else {
    display: none;
  }
}

/// Makes the target selector invisible.
///
/// @param {boolean} $forced [true] - Specifies whether !important is tagged.
///
/// @group alignments
@mixin invisible($forced:true) {
  @if ($forced == true) {
    visibility: hidden !important;
  }
  @else {
    visibility: hidden;
  }
}

/// Makes a video fill the parent block, maintaining aspect ratio and centered
/// (like background-size: cover).
///
/// @group alignments
@mixin cover-video() {
  @include abs-align('left' 50%, 'top' 50%);
  @include size(auto);
  min-width: 100%;
  min-height: 100%;
  transform: translate3d(-50%, -50%, 0);
}

/// Sets the overflow of the target selector.
///
/// @param {number|List} $overflowX - Specifies the overflow of the selector. If
///                                   only 1 value is provided, both overflow-x
///                                   and overflow-y will use that value. If 2
///                                   values are provided, they will be used for
///                                   overflow-x and overflow-y respectively.
/// @param {number}      $overflowY [unset] - Specifies the overflow-y value
///                                           (overrides the previous parameter)
///                                           if specified.
///
/// @group alignments
@mixin overflow($overflowX, $overflowY:unset) {
  $_overflowX: if(length($overflowX) > 1, nth($overflowX, 1), $overflowX);
  $_overflowY: if(length($overflowX) > 1, nth($overflowX, 2), $_overflowX);
  $_overflowY: if($overflowY == unset, $_overflowY, $overflowY);

  @if ($_overflowY == '') {
    $_overflowY: $_overflowX;
  }

  @if ($_overflowX != null) and ($_overflowX != '-') and ($_overflowX != 'x') and ($_overflowX != 'n') {
    overflow-x: $_overflowX;
  }

  @if ($_overflowY != null) and ($_overflowY != '-') and ($_overflowY != 'x') and ($_overflowY != 'n') {
    overflow-y: $_overflowY;
  }
}
